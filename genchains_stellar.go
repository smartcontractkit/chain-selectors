//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"slices"
	"strconv"
	"strings"
	"text/template"
	"unicode"

	chain_selectors "github.com/smartcontractkit/chain-selectors"
)

const filename = "generated_chains_stellar.go"

type chain struct {
	ChainID     string
	Selector    uint64
	Name        string
	VarName     string
	NetworkType string
}

var chainTemplate, _ = template.New("").Parse(`// Code generated by go generate please DO NOT EDIT
package chain_selectors

type StellarChain struct {
	ChainID     string
	Selector    uint64
	Name        string
	NetworkType NetworkType
}

var (
	{{- range . }}
	{{.VarName}} = StellarChain{ChainID: "{{ .ChainID }}",Selector: {{ .Selector }}, Name: "{{ .Name }}", NetworkType: {{ .NetworkType }}}
	{{- end }}
)

var StellarALL = []StellarChain{
	{{- range . }}
	{{ .VarName }},
	{{- end }}
}

`)

func main() {
	src, err := genChainsSourceCode()
	if err != nil {
		panic(err)
	}

	formatted, err := format.Source([]byte(src))
	if err != nil {
		panic(err)
	}

	existingContent, err := os.ReadFile(filename)
	if err != nil {
		panic(err)
	}

	if bytes.Equal(existingContent, formatted) {
		fmt.Println("stellar: no changes detected")
		return
	}

	err = os.WriteFile(filename, formatted, 0644)
	if err != nil {
		panic(err)
	}
}

func genChainsSourceCode() (string, error) {
	buf := &bytes.Buffer{}
	var chains []chain

	for chainID, chainSel := range chain_selectors.StellarChainIdToChainSelector() {
		name, err := chain_selectors.StellarNameFromChainId(chainID)
		if err != nil {
			return "", err
		}
		networkType, err := chain_selectors.StellarNetworkTypeFromChainId(chainID)
		if err != nil {
			return "", err
		}

		chains = append(chains, chain{
			ChainID:     chainID,
			Selector:    chainSel,
			Name:        name,
			VarName:     toVarName(name, chainSel),
			NetworkType: fmt.Sprintf("NetworkType%s", strings.Title(string(networkType))),
		})
	}

	slices.SortFunc(chains, func(a, b chain) int {
		if a.Name < b.Name {
			return -1
		} else if a.Name > b.Name {
			return 1
		}
		return 0
	})
	if err := chainTemplate.Execute(buf, chains); err != nil {
		return "", err
	}
	return buf.String(), nil
}

func toVarName(name string, chainSel uint64) string {
	const unnamed = "TEST"
	x := strings.ReplaceAll(name, "-", "_")
	x = strings.ToUpper(x)
	if len(x) > 0 && unicode.IsDigit(rune(x[0])) {
		x = unnamed + "_" + x
	}
	if len(x) == 0 {
		x = unnamed + "_" + strconv.FormatUint(chainSel, 10)
	}
	return x
}
