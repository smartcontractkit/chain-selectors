//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"os"
	"sort"
	"strconv"
	"strings"
	"unicode"

	chain_selectors "github.com/smartcontractkit/chain-selectors"
)

const filename = "generated_chains_ton.go"

type chain struct {
	ChainID   int32
	Selector  uint64
	Name      string
	VarName   string
	IsMainnet bool
}

var chainTemplate, _ = template.New("").Parse(`// Code generated by go generate please DO NOT EDIT
package chain_selectors

type TonChain struct {
	ChainID    int32
	Selector   uint64
	Name       string
	VarName    string
	IsMainnet  bool
}

var (
{{ range . }}
	{{.VarName}} = TonChain{ChainID: {{ .ChainID }}, Selector: {{ .Selector }}, Name: "{{ .Name }}", IsMainnet: {{ .IsMainnet }}}{{ end }}
)

var TonALL = []TonChain{
{{ range . }}{{ .VarName }},
{{ end }}
}

`)

func main() {
	src, err := genChainsSourceCode()
	if err != nil {
		panic(err)
	}

	formatted, err := format.Source([]byte(src))
	if err != nil {
		panic(err)
	}

	existingContent, err := os.ReadFile(filename)
	if err != nil {
		if os.IsNotExist(err) {
			fmt.Println("ton: no existing generations found")
			existingContent = nil
		} else {
			panic(err)
		}
	}

	if string(existingContent) == string(formatted) {
		fmt.Println("ton: no changes detected")
		return
	}
	fmt.Println("ton: updating generations")

	err = os.WriteFile(filename, formatted, 0644)
	if err != nil {
		panic(err)
	}
}

func genChainsSourceCode() (string, error) {
	var wr = new(bytes.Buffer)
	chains := make([]chain, 0)

	for ChainID, chainSel := range chain_selectors.TonChainIdToChainSelector() {
		name, err := chain_selectors.TonNameFromChainId(ChainID)
		if err != nil {
			return "", err
		}

		isMainnet, err := chain_selectors.TonIsMainnetChain(ChainID)
		if err != nil {
			return "", err
		}

		chains = append(chains, chain{
			ChainID:   ChainID,
			Selector:  chainSel,
			Name:      name,
			VarName:   toVarName(name, chainSel),
			IsMainnet: isMainnet,
		})
	}

	sort.Slice(chains, func(i, j int) bool { return chains[i].VarName < chains[j].VarName })
	if err := chainTemplate.ExecuteTemplate(wr, "", chains); err != nil {
		return "", err
	}
	return wr.String(), nil
}

func toVarName(name string, chainSel uint64) string {
	const unnamed = "TEST"
	x := strings.ReplaceAll(name, "-", "_")
	x = strings.ToUpper(x)
	if len(x) > 0 && unicode.IsDigit(rune(x[0])) {
		x = unnamed + "_" + x
	}
	if len(x) == 0 {
		x = unnamed + "_" + strconv.FormatUint(chainSel, 10)
	}
	return x
}
